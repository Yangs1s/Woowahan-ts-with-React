## 조건부 타입확장하기
### 1. extends와 제네릭을 활요한 조건부 타입

```ts
T extends U ? X : Y
```
T가 U에 할당 가능하면 X 타입, 아니면 Y 타입

### 조건부 타입을 사용하지 않을때 문제점.

핵심은 유니온타입을 사용하면 타입스크립트에서는 이게 어떤 반환타입인지 구분을 절대 못함.

예시가 어렵긴 하지만,
```ts
// 서버에서 받아오는 기본 타입
interface PayMethodBaseFromRes {
  financialCode: string;
  name: string;
}

// 은행 타입
interface Bank extends PayMethodBaseFromRes {
  fullName: string;
}

// 카드 타입
interface Card extends PayMethodBaseFromRes {
  appCardType?: string;
}

// 프론트엔드 UI 관련 타입
type PayMethodInterface = {
  companyName: string;
  // ...
}

// 최종 결제 수단 타입 (제네릭 활용)
type PayMethodInfo<T extends Bank | Card> = T & PayMethodInterface;
```


```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  // ... 구현
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess： (res) => {
    const usablePocketList =
        res?.filter((pocket： PocketInfo<Card> | PocketInfo<Bank>) => 
        pocket?.useType === "USE" ) ?? []；
    return usablePocketList;
    },
    })；

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  
  return result;
};
```

타입으로 card,appcard,bank를 받아서 해당 결제 수단의 결제 수단 정보 리스트를 반환함.

반환하는 Data 타입은 
```ts
 PocketInfo<Card> || PocketInfo<Bank>
``` 

- 사용자가 타입으로 card를 넣을시 : 
    - useGEtRegisteredList함수가 반환하는 Data타입은 PocketInfo라 유추 가능, 하지만 useGeRegisterdList가 반환하는 Data타입은 PayMethodType이기 때문에 사용하는 쪽에서는 PocketInfo일 가능성도 있음.
    -    여기서 사용자(개발자), 사용하는쪽(타입스크립트)인거 같습니다.

- useGetRegisteredList함수는 타입을 구분해서 넣는 사용자의 의도와는 다르게 정확하게 타입 반환이 안됨. 

==> 타입설정이 유니온으로만 되있기에 타입스크립트는 해당타입에 맞는 Data타입을 추론하기 어렵다. 그래서 조건부 타입을 활용해야함.


### extends 조건부 타입을 활용하여 개선하기

```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = <T extends "card" | "appCard" | "bank">(
  type: T
): UseQueryResult<PayMethodType[]> => {
  // ... 구현
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess： (res) => {
    const usablePocketList =
        res?.filter((pocket： PocketInfo<Card> | PocketInfo<Bank>) => 
        pocket?.useType === "USE" ) ?? []；
    return usablePocketList;
    },
    })；

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  
  return result;
};
```

- 제네릭과 extends를 함께 사용해 제네릭으로 받는 타입을 제한했다. 따라서 개발자는 잘못된 값을 넘길 수
없기 때문에 휴먼 에러를 방지할 수 있다.
- extends를 활용해 조건부 타입을 설정했다. 조건부 타입을 사용해서 반환 값을 사용자가 원하는 값으로 구
체화할 수 있었다. 이에 따라 불필요한 타입 가드, 타입 단언 등을 방지할 수 있다.


#### 실무 적용 포인트 (AI를 통해서 물어봤을떄)

- 언제 조건부 타입을 사용할까?
    -   ✅ 함수 입력에 따라 출력 타입이 달라질 때
    -   ✅ API 응답 타입이 요청 파라미터에 따라 달라질 때
    -   ✅ 유니온 타입 사용 시 타입 가드가 너무 많아질 때


책의 예시를 보면 type bank가 들어가냐 card,appcard가 들어가냐에 따라 달라짐.


### infer를 활용해서 타입 추론하기

extends를 사용할때, infer 키워드를 사용할수 있다.

infer의 사전적의미는 추론하다라는 의미를 지님.

타입스크립트서도 추론하는 역할을 함.

삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고, infer로 타입을 추론하는 방식을 취함.

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

>```ts
> - T가 Promise<infer K>[] 형태인지 확인
> - 맞다면 Promise 안의 타입을 K로 추론해서 반환
> - 아니면 any 반환
> ```


실무의 예시로 라이더 어드민 서비스서 이용하는 타입을 예시로 들어줌


```ts
interface RouteBase {
  name: string;  // ❌ 그냥 string
  path: string;
  component: ComponentType;
}

export interface RouteItem {
  name: string;  // ❌ 그냥 string
  path: string;
  component?: ComponentType;
  pages?: RouteBase[];
}

// 라우트 정의
export const routes: RouteItem[] = [
  {
    name: "기기 내역 관리",
    path: "/device-history",
    component: DeviceHistoryPage,
  },
  {
    name: "헬멧 인증 관리",
    path: "/helmet-certification",
    component: HelmetCertificationPage,
  },
];

// 메뉴 타입 정의
export interface SubMenu {
  name: string;  // ❌ 그냥 string
  path: string;
}

export interface MainMenu {
  name: string;  // ❌ 그냥 string
  path?: string;
  subMenus?: SubMenu[];
}

export type MenuItem = MainMenu | SubMenu;

// 메뉴 정의
export const menuList: MenuItem[] = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
];
```
내용이 뭔가 제 머리로는 이해는 안되는데요

핵심적인거만 이해하면,

menuList는 유니온으로 (MainMenu | SubMenu)로 이뤄져있고,
routes는 구조가 또 다르기에 name값의 위치가 구조마다 다름.

mainList안에 서브가 없다면 mainList.name이 권한비교 대상이고,
있다면 subList.name이 권한비교 대상이다.
routes에서는 RouteItem.name이다.

결국 name을 기준으로 권한을 판단하게 된다.

name을 그냥 스트링으로 쓰게 되면,어디서든 name을 스트링으로 아무렇게나 써도 컴파일 단계에서 에러가 나지 않는다는것이다. 

권한체크를 올바르게작동하려면, name값의 정확한 문자열로 통일이 되어야한다.


처음엔, menuList에서 name값을 타입으로 만들어서 추출하는데

```ts
type PermissionNames = "기기 정보 관리" | "안전모 인증 관리" | "운행 여부 조회"; // ...
```
권한 검사가 필요없는 name들도 있는데 얘네는 또 따로 관리해야하니까 유지보수 측면에서 어렵습니다.

그래서 이것을 해결하기위해, 필자는 infer + as const로 불변객체를 만드는것을 해결 방법으로 얘기하고 있습니다.

as const로 리터럴 타입 + 읽기전용으로 배열을 만듬.

```ts
export const menuList = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
] as const;  // ✅ 불변 객체로 만듦
```
as const를 사용해서, name값이 리터럴 타입으로 고정됨. 결국 타입을 좁혀서 정확하게 체크하기 위해서 만들어 놓고,


```ts
type UnpackMenuNames<T extends ReadonlyArray<MenuItem>> = 
  
  // ═══════════════════════════════════════════════════════════
  // 1단계: 배열인가?
  // ═══════════════════════════════════════════════════════════
  T extends ReadonlyArray<infer U>
    ? // ─────── Yes: 배열임 (U = 배열 요소 타입)
      
      // ═══════════════════════════════════════════════════════
      // 2단계: U가 MainMenu인가?
      // ═══════════════════════════════════════════════════════
      U extends MainMenu
        ? // ─────── Yes: MainMenu임
          
          // ═════════════════════════════════════════════════
          // 3단계: subMenus 추출
          // ═════════════════════════════════════════════════
          U["subMenus"] extends infer V
            ? // ─────── subMenus를 V로 추출 성공
              
              // ═══════════════════════════════════════════
              // 4단계: V가 SubMenu 배열인가?
              // ═══════════════════════════════════════════
              V extends ReadonlyArray<SubMenu>
                ? UnpackMenuNames<V>  // ✅ Yes: 재귀 호출
                : U["name"]           // ✅ No: MainMenu의 name 반환
              
            : never  // ← 3단계 실패 (여기는 거의 안 옴)
          
        : // ─────── No: MainMenu 아님
          
          // ═════════════════════════════════════════════════
          // 2단계(else): U가 SubMenu인가?
          // ═════════════════════════════════════════════════
          U extends SubMenu
            ? U["name"]  // ✅ Yes: SubMenu의 name 반환
            : never      // ✅ No: 둘 다 아님
    
    : never  // ← 1단계 실패: 배열 아님
```
unpackMenuNames를 다시 명확하게 정의합니다.

최종 PermissionNames 타입을 만듬.
```ts
export type PermissionNames = UnpackMenuNames<typeof menuList>;
```

코드가 보기 넘 힘들고 어려워서 클로드로 들여쓰기에 단계별로 쉽게 설명좀 해달라고 했습니다..
근데도 솔직히 진짜 infer로 설명하는거 UnpackMenuNames가 진짜 이해도,보기에도 너무 어렵습니다.

infer가 결국엔 어떤 타입인지 모를떄, 복잡한 구조안에서, 그 타입이 뭔지 모르니까 자동적으로 추론해서 쓰이는거구나 정도로 이해했습니다.

한번도 써본적이 없다보니까 감이 안잡히네요. 나중에 실무에서 이런 케이스가 있다면, 써보고 싶은데 그때 되면 생각이 날까? 싶습니다.. ㅠㅠ



