## 1. 타입이란?

### 자바스크립트의 데이터 타입

자바스크립트는 다음과 같이 7가지 데이터타입(자료형)을 정의한다.

```js
undefined
null
Boolean
String
Symbol
Numeric //(Number와BigInt)
Object
```

> 여러 종류의 데이터를 식별해서 컴파일러에 값의 형태를 알려준다.  
> 메모리에 저장된 값을 데이터 타입으로 설명할 수 있고 모든 데이터를 해석할 때 데이터 타입 체계가 사용된다.

### 집합으로서의 타입

프로그래밍에서 타입은 **값이 가질 수 있는 유효한 범위의 집합**을 말한다.

```ts
function greet(name: string): string {
  return `Hello, ${name}!`;
}

greet("World");
greet(42); // Error: Argument of type '42' is not assignable to parameter of type 'string'.
```

타입 시스템은 코드에서 사용되는 **유효한 값의 범위를 제한**해서 **런타임에서 발생할 수 있는** **유효하지 않은 값에 대한 에러를 방지**한다.

### 정적 타입과 동적 타입

-   **정적타입** : 모든 변수의 타입이 **컴파일 타임**에서 결정
-   **동적타입** : 변수 타입이 **런타임**에서 결정

```ts
int number = 23 //자바, 정적

let number : number = 123 //타입스크립트, 정적
let number = 123 //자바스크립트, 동적
```

> - 컴파일 타임: 기계가 소스코드를 이해할 수 있도록 변환되는 시점  
> - 런타임: 컴파일 이후 변환된 파일이 메모리에 적재되어 실행되는 시점

### 강타입과 약타입

자바스크립트는 런타임에 타입이 자동적으로 변경되는 **암묵적 타입변환** 특징이 있다.

```ts
"2" -1 //1 자바스크립트의 형변환
```
-   **강타입** : 서로 다른 타입을 갖는 값끼리 연산을 시도하면 컴파일러 또는 인터프리터에서 에러 발생
-   **약타입** : 암묵적으로 타입 변환이 일어나 연산을 수행

### 컴파일 방식

보통 컴파일은 고수준 언어를 저수준 언어로 바꾸는 과정을 뜻하지만, 타입스크립트는 컴파일해도 결과물이 여전히 자바스크립트이다. 타입스크립트의 목적은 사람이 보기 쉽게 쓰는 것이 아니라 실행하기 전에 타입 검사를 통해 오류를 미리 찾아내는 것이다. 따라서 컴파일 후에는 타입 정보가 사라지고 순수한 자바스크립트 코드만 남는다.

> TS -> 컴파일 -> JS. (자바스크립트의 컴파일 타임에 런타임 에러를 사전에 잡아낸다.)

## 2. 타입스크립트의 타입 시스템

### 타입 애너테이션 방식

타입을 명시적으로 선언해서 어떤 값을 갖는지 컴파일러에 직접 알려주는 문법이다.

```ts
// 타입 에너테이션
const a: number = 10;
const b: string = "hello";
const c: boolean = true;
```

### 구조적 타이핑

이름으로 타입을 구분하는 명목적인 타입 언어의 특징과 달리 **타입스크립트는 구조로 타입을 구분**한다

> 이와 반대되는 명목적 타이핑이란 이름으로 타입을 구분하기 때문에 구조가 같더라도 이름이 다르면 다른 타입으로 취급한다.

```ts
//구조적 타이핑
interface Person {
  name: string;
  age: number;
}

interface Product {
  name: string;
  age: number;
}

let person: Person = { name: "mike", age: 23 };
let product: Product = { name: "apple", age: 1000 };

person = product; //구조적으로 호환되어서 에러가 나지 않는다.
```

타입은 특정 값들이 모여 있는 집합이다. 하나의 값은 여러 타입 집합에 동시에 속할 수 있다.

### 구조적 서브타이핑

객체가 가지고 있는 속성(프로퍼티)을 바탕으로 타입을 구분한다.

**이름이 다른 객체라도 가진 속성이 동일하다면 타입스크립트는 서로 호환이 가능한 동일한 타입으로 여긴다.**

```ts
//서브 타이핑
interface Person {
  name: string;
}

interface Mike {
  name: string;
  age: number;
}

let person: Person;
let mike: Mike = { name: "mike", age: 23 };

person = mike; // 서브 타이핑
```


> Mike는 Person이 요구하는 **모든 것, 그 이상**을 가지고 있다.
> 
> - Person이 필요한 것: name만
> - Mike가 가진 것: name + age

→ Mike는 Person의 **서브타입!**

```ts
function greet(p: Person) {
  console.log(`안녕, ${p.name}!`);
  // p.age는 사용 안 함 (Person에 없으니까)
}

greet(mike); // ✅ 작동!
// mike는 name을 가지고 있으니까 Person으로 취급 가능
```

### 타입스크립트는 왜 명목적 타이핑 대신 구조적 타이핑을 쓸까?

명목적 타이핑은 개발자가 지정한 이름이 다르면 같은 구조라도 다른 타입으로 취급한다. 그래서 더 엄격하고 안전하지만, 자바스크립트의 성격과는 맞지 않는다. 자바스크립트는 덕 타이핑을 기반으로 하여, 값이 올바른 형태만 갖추면 그 값이 어디서 왔는지 따지지 않고 사용한다. 타입스크립트는 이런 특징을 따르기 위해 구조적 타이핑을 채택했고 덕분에 더 유연하게 타입을 다룰 수 있다.

> *덕 타이핑: 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속한다고 간주
> ("어떤 새가 오리처럼 걷고, 꽥꽥거리면 나는 그 새를 오리로 볼 것이다")


* 덕 타이핑과 구조적 타이핑의 차이는 "타입을 검사하는 시점"에 있다.
  - 덕 타이핑: 런타임에 타입 검사  
  - 구조적 타이핑: 컴파일 타임에 타입체커가 타입 검사

### 구조적 타이핑의 결과

```ts
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(cube: Cube) {
  let total = 0;

  for (const axis of Object.keys(cube)) {
    const length = cube[axis];
    total += length;
  }

  return total;
}

// Element implicitly has an 'any' type 
// because expression of type 'string' can't be used to index type 'Cube'.
// No index signature with a parameter of type 'string' was found on type 'Cube'.
```

Cube 인터페이스의 모든 필드는 number로 정의되어 있으니 c[axis]도 당연히 number일 것처럼 보인다. 하지만 실제로는 cube에 width, height, depth 외에도 다른 속성이 들어올 수 있다. 그 결과 c[axis]의 타입이 string이 될 수도 있어 오류가 난다.

> 이는 구조적 타이핑 때문에 발생하는데 cube 타입 값이 필요한 자리에도 name 같은 추가 속성을 가진 객체를 넣을 수 있기 때문이다.

???? 글만 읽으면 이게 무슨 소리인가 싶다.

코드와 함께 다시 한번 살펴보자.

```ts
interface Cube {
  width: number;
  height: number;
  depth: number;
}

// 이렇게 넣을 수도 있음! (구조적 타이핑)
const myCube: Cube = {
  width: 10,
  height: 20,
  depth: 30,
  color: "red"  // 👈 추가 속성! Cube에 없는데 가능!
};
```

**왜 가능?** 구조적 타이핑 = Cube가 요구하는 것(width, height, depth)만 있으면 오케이니까.

```ts
function addLines(cube: Cube) {
  for (const axis of Object.keys(cube)) {
    // axis가 "color"일 수도 있음!
    const length = cube[axis];
    //                  👆 "red" 나올 수도 있어서 위험!
    total += length; // 💥 문자열 + 숫자?
  }
}
```

**Cube 타입이라고 해도, 실제로는 width/height/depth 외에 다른 속성도 있을 수 있어서** **cube[axis]가 항상 number라고 보장 할 수 없다** 
즉, 타입스크립트에서 구조적 타이핑 = 최소 요구사항만 체크 → 추가 속성은 막을 수 없음 → 안전하지 않음! 으로 간주된다.

```ts
for (const axis of Object.keys(cube)) {
  const length = cube[axis as keyof Cube];
  total += length;
}

// 가장 간단한 해결법은 axis가 Cube의 키와 일치한다고 간주하면 된다.
// as: 타입 단언

// TypeScript: "axis로 string이 올수도 있잖아. 믿을 수 없어!"
// 개발자: "as keyof Cube 👈 내가 보장할게, 이건 width/height/depth야"
// TypeScript: "오케이, 너를 믿을게"
```

### 타입스크립트의 점진적인 타입 확인

점진적 타입 검사는 컴파일 시 타입을 검사하면서도 필요할 때는 타입 선언을 생략할 수 있게 한다. 타입을 지정한 변수나 표현식은 정적으로 검사하지만 선언을 생략하면 암시적으로 any 타입으로 추론해 동적으로 다룬다. 모든 타입을 지정할 필요는 없지만 타입 정보를 모두 알 때 가장 안정적이고 정확한 검사를 받을 수 있다.

> 자바스크립트를 타입스크립트로 마이그레이션할때 점진적인 타입 도입이 가능하다

### 📝any 타입
타입스크립트에서 any는 모든 타입을 포함하는 최상위 타입으로, 어떤 값이든 할당할 수 있다.

### 자바스크립트 슈퍼셋으로서의 타입스크립트

모든 자바스크립트 코드는 타입스크립트로 볼 수 있지만, 반대로 타입스크립트 코드가 자바스크립트 코드인것은 아니다.

> 타입스크립트 ⊃ 자바스크립트

### 값 vs 타입

값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다.

타입스크립트 문법인 type으로 선언한 내용은 자바스크립트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다.

```ts
type Person = { name: string };
const Person = { name: "철수" };

// 컴파일 후 (JavaScript)
const Person = { name: "철수" };
// type은 사라짐! 값만 남음
```

class와 enum처럼 값과 타입 공간에 동시에 존재하는 심볼도 있다.

```ts
// 일반 타입 (컴파일 후 사라짐)
type User = { name: string };
console.log(User);  // ❌ 런타임에 없음

// Enum (컴파일 후 남음)
enum Role { Admin, User }
console.log(Role);  // ✅ { 0: 'Admin', 1: 'User', Admin: 0, User: 1 }

// Class (컴파일 후 남음)
class Animal {}
console.log(Animal);  // ✅ [Function: Animal]
```

### 타입을 확인하는 방법

타입을 확인하는 typeof 도 값과 타입에 따라 역할이 나뉜다.

-   값에서 사용된 typeof는 자바스크립트 런타임의 typeof 연산자가 된다
-   타입에서 사용된 typeof는 값을 읽고 타입스크립트 타입을 반환한다.

```ts
const name = "철수";

typeof name           // "string" (JS, 값)
type NameType = typeof name;  // string (TS, 타입)
```
