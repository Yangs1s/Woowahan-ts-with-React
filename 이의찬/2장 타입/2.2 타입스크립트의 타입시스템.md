## 2.2 타입스크립트의 타입 시스템

### 구조적 타이핑 & 구조적 서브타이핑

이름으로 타입을 구분하는 명목적인 타입 언어(C, 자바 등)와 달리 **타입스크립트는 구조로 타입을 구분**한다. 이것을 **구조적 타이핑**이라고 한다.

타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 따라서 타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있다.

```tsx
type stringOrNumber = string | number;
```

집합으로 나타내는 타입스크립트의 시스템을 지탱하는 개념이 **구조적 서브타이핑**이다.

구조적 서브타이핑은 **객체가 가지고 있는 속성으로 타입을 구분**하는 것이다. 이름이 달라도 **속성이 같으면 서로 호환이 가능한 타입**으로 여긴다. 

> 구조로 구분하니까 이름이 달라도 상관없다!
> 

```tsx
interface Pet {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

// ✅ OK
pet = cat; 
// ❌ NO
cat = pet;
```

Cat은 Pet과 다른 타입으로 선언되었지만, name 속성을 가지고 있기에 cat을 pet에 할당 가능하다. 

![image.png](attachment:692a7e19-2c7a-46d1-9ac3-82edd35a4765:image.png)

반대로 pet은 cat에 할당할 수 없다. pet에 age 속성이 없기 때문이다.

```tsx
interface Pet {
  name: string;
}

let cat = { name: "Zag", age: 2 };
function greet(pet: Pet) {
  console.log("Hello, " + pet.name);
}

greet(cat); // ✅ OK
```

위 함수에서도 동일하게, greet의 매개변수로 Pet타입을 요구하지만, cat 객체를 전달해도 정상적으로 동작한다.

또한 타입의 상속 역시 구조적 타이핑을 기반으로 동작한다.

```tsx
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`);
}

const developer = new Developer("zig", 20, 7);
greet(developer); // Hello, I'm zig
```

Developer 클래스가 Person 클래스를 상속받지 않아도, greet(developer)는 정상적으로 동작한다.

> 서로 다른 타입간의 호환성은 **할당을 하건, 상속을 하건, 매개변수로 사용되건 모두 내부 구조에 의해서 판단**된다.
> 

### 자바스크립트를 닮은 타입스크립트

이런 타입 시스템과 대조적인 방식이 명목적 타이핑이다. 명목적 타이핑은 타입의 구조 대신 이름만을 가지고 구분하는 것으로 C++, 자바 등에서 사용된다. 

명목적 타이핑은 ****타입의 동일성을 확인하는 과정에서 조금 더 안전하다. 개발자의 의도가 반영되기 때문이다. 하지만 **자바스크립트가 덕 타이핑**을 기반으로 한 언어이기에, **타입스크립트는 구조적 타이핑**을 채택했다.

> 덕 타이핑 : "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 그 새를 오리라 부를 것이다.”
> 

덕 타이핑은 함수의 매개변숫값이 올바르게 주어진다면, 그 값이 어떻게 만들어졌는지는 신경쓰지 않고 사용한다는 개념이다.

덕 타이핑과 구조적 타이핑은 구분되지만, 코드만 보면 차이가 없다. 차이는 검사하는 시점에 발생한다. **덕 타이핑은 런타임에 타입을 검사**하고, **구조적 타이핑은 컴파일 타임에 타입을 검사**한다.

### 구조적 타이핑의 결과

구조적 타이핑으로 인해 예상치 못한 결과가 나올수도 있다.

```tsx
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axios of Object.keys(c)) {
    // 🚨 Element implicitly has an 'any' type
    // because expression of type 'string' can't be used to index type 'Cube'
    // 🚨 No index signature with a parameter of type 'string'
    // was found on type 'Cube'
    const length = c[axis];
    total += length;
  }
}
```

c는 Cube 타입으로 선언되었고, Cube 인터페이스의 모든 필드는 number 타입을 가지기 때문에 `c[axis]`는 당연히 number 타입으로 생각할 수 있다. 하지만 **c에 들어올 객체가 Cube 타입이 아닌 더 많은 속성을 가진 타입일 수 있어 에러가 발생**한다.

> 가능성만으로 에러가 발생할 수 있다는게 좀 골때리는 부분, 입력값에 따로 타입을 명시해줘야..
> 

```tsx
const nameCube = {
  width: 6,
  height: 6,
  depth: 4,
  name: "SweetCube", // string 타입의 추가 속성이 정의되었다
};

addLines(nameCube); // ✅ OK
```

### 타입스크립트의 점진적 타입 확인

타입스크립트는 **점진적으로 타입을 확인**하는 언어다. 타입을 지정하면 정적으로 타입을 검사하지만, 타입을 생략하면 동적으로 검사를 수행하고 암시적 타입 변환이 일어나게 된다.

```tsx
function add(x, y) {
	return x + y;
}
// 위 코드는 아래와 같이 암시적 타입 변환이 일어난다
function add(x： any, y： any)： any;
```

그렇기에 타입스크립트에서 프로그램을 컴파일 할 때, 모든 타입을 알아야하는 것은 아니다. 자바스크립트 코드를 타입스크립트로 마이그레이션 할 때 이런 속성을 유용하게 쓸 수 있다.

### 자바스크립트 슈퍼셋으로서의 타입스크립트

**모든 자바스크립트 코드는 타입스크립트**라고 볼 수 있지만 반대로 **모든 타입스크립트 코드가 자바스크립트 코드인 것은 아니다.** 다음 코드는 타입스크립트에서는 잘 동작하지만, 자바스크립트에서는 에러가 발생한다.

```tsx
function greet(name： string) {
	console.log(Hello", name);
}
```

### 값 vs 타입

값 공간과 타입 공간의 이름은 서로 충돌하지 않기 때문에 타입과 변수를 같은 이름으로 정의할 수 있다. 타입스크립트 문법은 자바스크립트 런타임에서 제거되기 때문이다.

### 타입을 확인하는 방법

`typeof`, `instanceof` 그리고 타입 단언을 사용해서 타입을 확인할 수 있다. typeof는 자바스크립트의 7가지 원시 타입과 Function 그리고 object 객체를 반환한다.

> 놀랍게도 `typeof null`도 object를 반환한다.
> 

`instanceof` 연산자를 사용하면 프로토타입 체이닝 어딘가에 생성자의 프로토타입 속성이 존재하는지 판단할 수 있다.