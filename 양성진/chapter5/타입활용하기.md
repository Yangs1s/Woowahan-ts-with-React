## 조건부 타입


extends와 삼항 연산자를 이용해 조건에 따라 각각 다른 타입을 정의하도록 돕는 문법입니다.


### 1. extends와 제네릭을 활용한 조건부 타입

```ts
T extends U ? X : Y
```
T가 U에 할당 가능하면 X 타입, 아니면 Y 타입

### 조건부 타입을 사용하지 않을 때의 문제

유니온 타입만으로는 "입력과 출력의 타입이 연결되지 않아" 반환 타입을 구체화하기 어렵다.

예시:
```ts
// 서버에서 받아오는 기본 타입
interface PayMethodBaseFromRes {
  financialCode: string;
  name: string;
}

// 은행 타입
interface Bank extends PayMethodBaseFromRes {
  fullName: string;
}

// 카드 타입
interface Card extends PayMethodBaseFromRes {
  appCardType?: string;
}

// 프론트엔드 UI 관련 타입
type PayMethodInterface = {
  companyName: string;
  // ...
}


```


```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  // ... 구현
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) => pocket?.useType === "USE"
        ) ?? [];
      return usablePocketList;
    },
  });

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  return result;
};
```

타입으로 "card/appcard/bank"를 받아 결제 수단 리스트를 반환한다.

반환 데이터의 의도:
```ts
 PocketInfo<Card> || PocketInfo<Bank>
``` 

- 문제점: 호출부에서 "card"를 넣어도 반환 타입은 항상 `PayMethodInfo<Card> | PayMethodInfo<Bank>`로 추론되어, Card/Bank 공통 속성만 안전하게 접근 가능하다.
- 결론: 입력값과 반환 타입을 연결하려면 조건부 타입이 필요하다.


### 조건부 타입으로 개선하기 (입력-출력 타입 연결)

```ts
// 입력 리터럴에 따라 결과 타입을 매핑
type ResultByType<T extends "card" | "appcard" | "bank"> =
  T extends "card" | "appcard" ? Card : Bank;

export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<ResultByType<T>> => {
  // ... 구현 (fetcher 내부 로직 동일)
  const fetcher = fetcherFactory<ResultByType<T>>({
    onSuccess: (res) => {
      // 실제 구현에서는 런타임 분기 또는 서버 응답 형태에 맞게 처리
      return res;
    },
  });

  const result = useCommonQuery<ResultByType<T>[]>(url, undefined, fetcher);
  return result;
};
```

- 제네릭 + extends로 입력 리터럴을 제한해 휴먼 에러를 방지한다.
- 조건부 타입으로 "입력에 따른 반환 타입"을 정확히 연결해 타입 가드/단언 방지를 할 수 있다.



### infer를 활용해서 타입 추론하기

extends를 사용할때, infer 키워드를 사용할수 있다.

infer의 사전적의미는 추론하다라는 의미를 지님.

타입스크립트서도 추론하는 역할을 함.

삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고, infer로 타입을 추론하는 방식을 취함.

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

 - T가 Promise<`infer K`>[] 형태인지 확인
 - 맞다면 Promise 안의 타입을 K로 추론해서 반환
 - 아니면 any 반환


실무의 예시로 라이더 어드민 서비스서 이용하는 타입을 예시로 들어줌


```ts
interface RouteBase {
  name: string;  // ❌ 그냥 string
  path: string;
  component: ComponentType;
}

export interface RouteItem {
  name: string;  // ❌ 그냥 string
  path: string;
  component?: ComponentType;
  pages?: RouteBase[];
}

// 라우트 정의
export const routes: RouteItem[] = [
  {
    name: "기기 내역 관리",
    path: "/device-history",
    component: DeviceHistoryPage,
  },
  {
    name: "헬멧 인증 관리",
    path: "/helmet-certification",
    component: HelmetCertificationPage,
  },
];

// 메뉴 타입 정의
export interface SubMenu {
  name: string;  // ❌ 그냥 string
  path: string;
}

export interface MainMenu {
  name: string;  // ❌ 그냥 string
  path?: string;
  subMenus?: SubMenu[];
}

export type MenuItem = MainMenu | SubMenu;

// 메뉴 정의
export const menuList: MenuItem[] = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
];
```
내용이 뭔가 제 머리로는 이해는 안되는데요

핵심적인거만 이해하면,

menuList는 유니온으로 (MainMenu | SubMenu)로 이뤄져있고,
routes는 구조가 또 다르기에 name값의 위치가 구조마다 다름.

mainList안에 서브가 없다면 mainList.name이 권한비교 대상이고,
있다면 subList.name이 권한비교 대상이다.
routes에서는 RouteItem.name이다.

결국 name을 기준으로 권한을 판단하게 된다.

name을 그냥 스트링으로 쓰게 되면,어디서든 name을 스트링으로 아무렇게나 써도 컴파일 단계에서 에러가 나지 않는다는것이다. 

권한체크를 올바르게작동하려면, name값의 정확한 문자열로 통일이 되어야한다.


처음엔, menuList에서 name값을 타입으로 만들어서 추출하는데

```ts
type PermissionNames = "기기 정보 관리" | "안전모 인증 관리" | "운행 여부 조회"; // ...
```
권한 검사가 필요없는 name들도 있는데 얘네는 또 따로 관리해야하니까 유지보수 측면에서 어렵습니다.

그래서 이것을 해결하기위해, 필자는 infer + as const로 불변객체를 만드는것을 해결 방법으로 얘기하고 있습니다.

as const로 리터럴 타입 + 읽기전용으로 배열을 만듬.

```ts
export const menuList = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
] as const;  // ✅ 불변 객체로 만듦
```
as const를 사용해서, name값이 리터럴 타입으로 고정됨. 결국 타입을 좁혀서 정확하게 체크하기 위해서 만들어 놓고,


```ts
type UnpackMenuNames<T extends ReadonlyArray<MenuItem>> = 
  
  // ═══════════════════════════════════════════════════════════
  // 1단계: 배열인가?
  // ═══════════════════════════════════════════════════════════
  T extends ReadonlyArray<infer U>
    ? // ─────── Yes: 배열임 (U = 배열 요소 타입)
      
      // ═══════════════════════════════════════════════════════
      // 2단계: U가 MainMenu인가?
      // ═══════════════════════════════════════════════════════
      U extends MainMenu
        ? // ─────── Yes: MainMenu임
          
          // ═════════════════════════════════════════════════
          // 3단계: subMenus 추출
          // ═════════════════════════════════════════════════
          U["subMenus"] extends infer V
            ? // ─────── subMenus를 V로 추출 성공
              
              // ═══════════════════════════════════════════
              // 4단계: V가 SubMenu 배열인가?
              // ═══════════════════════════════════════════
              V extends ReadonlyArray<SubMenu>
                ? UnpackMenuNames<V>  // ✅ Yes: 재귀 호출
                : U["name"]           // ✅ No: MainMenu의 name 반환
              
            : never  // ← 3단계 실패 (여기는 거의 안 옴)
          
        : // ─────── No: MainMenu 아님
          
          // ═════════════════════════════════════════════════
          // 2단계(else): U가 SubMenu인가?
          // ═════════════════════════════════════════════════
          U extends SubMenu
            ? U["name"]  // ✅ Yes: SubMenu의 name 반환
            : never      // ✅ No: 둘 다 아님
    
    : never  // ← 1단계 실패: 배열 아님
```
unpackMenuNames를 다시 명확하게 정의합니다.

최종 PermissionNames 타입을 만듬.
```ts
export type PermissionNames = UnpackMenuNames<typeof menuList>;
```

코드가 보기 넘 힘들고 어려워서 클로드로 들여쓰기에 단계별로 쉽게 설명좀 해달라고 했습니다..
근데도 솔직히 진짜 infer로 설명하는거 UnpackMenuNames가 진짜 이해도,보기에도 너무 어렵습니다.

infer가 결국엔 어떤 타입인지 모를떄, 복잡한 구조안에서, 그 타입이 뭔지 모르니까 자동적으로 추론해서 쓰이는거구나 정도로 이해했습니다.

한번도 써본적이 없다보니까 감이 안잡히네요. 나중에 실무에서 이런 케이스가 있다면, 써보고 싶은데 그때 되면 생각이 날까? 싶습니다.. ㅠㅠ



### 템플릿 리터럴 타입 활용하기

타입스크립트에서는 유니온타입을 사용하여 변수 타입을 특정 문자열로 지정 할수 있다.

```ts

type headingNumber = 1 | 2 | 3 | 4 | 5;

type HeaderTag = `h${headingNumber}`
```

## 커스텀 유틸리티 타입 활용하기
유틸리티 타입을 활용해서 커스텀 유틸리티 타입을 제작해서 사용할수 있다.

### 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기

```ts
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
};

// ✅ Pick 사용 (좋은 방법)



export const Hr:VFC<props> = ({height,color,isFull,className}) => {
    ...
    return <HrComponent height={height} color={color} isFull={isFull}/>
}


// style.ts

type StyledProps = {
  height?: string;     
  color?: keyof typeof colors;  
  isFull?: boolean;    
};


const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) => height || "10px"};
  background-color: ${({ color }) => colors[color || "gray7"]};
  ${({ isFull }) => isFull && css`margin: 0 -15px;`}
`;
```

Hr컴포넌트와 style.ts안에 HrComponent는 받는 Props속성이 같습니다.

Props와 StyledProps는 className을 제외한 나머지는 같습니다. 
결국 타입이 몇개가 중복이 되는데 저게 타입이 많아지면 중복되는게 많아지면서 관리하기 어려워집니다.

그럴떄 Pick,Omit으로 커스텀해서 개선할수 있습니다.

```ts

type StyledProps = Pick<Props,'height' | 'color' |'isFull'>
```

이런식으로 코드 중복도 방지되고, 간결해지는걸 볼수 있습니다.

### PickOne 커스텀 유틸리티 타입을 활용해서 만들어보자. 

서로 다른 2개 이상의 객체를 유니온 타입으로 받을때, 타입 검사가 재대로 진행되지 않은 이슈.

```ts
type Card = {
  card: string;
}

type Account ={
  account : string;
}

function withdraw(type: Card | Account) {
  ...
}

withdraw({card : 'hyundai', account: 'hana'})

```

기존의 4장에서, 식별할 수 있는 유니온타입으로 만들수 있지만, 이미 만들어져있는걸 바꾸는건 쉽지 않음.


### 구현하는것.

여러 속성중 하나의 속성만 받는 커스텀 유틸리티 타입을 구현.

#### 1. 정확하게 어떤 것을 구현할지 타입을 정해야한다.


```ts

type Card = {
  card :string;
}

type Account = {
  account: string
}
```

Card 와 Account가 구현해야하는 타입으로 정하고,

#### 2. 원치 않는 속성에 값을 넣었을때, 의도적으로 에러 발생하기 

이것은 원하는 속성을 제외한 나머지는 에러를 일으키고 원하고자 하는 속성만 받도록 구현 하는것이다.

- 옵셔널 + undefined로 타입을 지정하기

```ts
// card 의 속성만 받고 싶다면

{account?:undefined; card:string;}

// accout의 속성만 받고 싶다면,
{account:undefined; card?:string;}
```

속성을 하나 더 추가해서 이해해보면

```ts
type PayMethod =
| { account： string; card?： undefined; payMoney?： undefined }
| { account?： undefined; card： string; payMoney?： undefined }
| { account?： undefined; card?： undefined; payMoney： string };
```

이를 커스텀 유틸리티 타입으로 구현하면,

```ts
type PickOne<T> = {
  [P in keyof T]: Record<P,T[P]> & Partial<Record<Exclude<keyof T,P>,undefined>>>
}[keyof T]
```

내용은 좀 어려웠는데, 제가 이해한 흐름은
#### One<`T`>

```ts
type One<T> = {[P in keyof T]:Record<P,T[P]>}[keyof T]
```

- [P in keyof T] : P는 T객체의 키값.
- Record<P,T[P]> : 키는 P타입, Value는 P를 키값으로 둔 T 객체의 값의 레코드 타입.
- 키는 T객체의 키값, value는 해당 키의 원복 객체 T를 말함.


```ts
// card로 예시를 들면

//keyof Card = 'card',

//[P in keyof T] => [P in 'card']
// P가 카드면,
//P = 'card'

// Record<P,T[P]> = Record<'card',Card['card']>
// => Record<'card',string> = {card:string;} 
// {[P in keyof Card]: Record<P,Card[P]>}

// P가 card니까

// { card:Record<"card",string> }
// 키는 card, 값은 {card:string};
// 결국은
// {card: {card:string}} 이런 형태에서
// [keyof T]

type Temp = {
  card:{card:string};
}

Temp[keyof Card] = Temp["card"] = {card :string}

```
그래서 아래의 결과는 맞게되는것.!
```ts
type Card = { card： string };
const one: One<Card> = { card： "hyundai" };
```
#### ExcludeOne<`T`>
```ts
type ExcludeOne<T> = { 
  [P in keyof T]: Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T];
```
ExcludeOne<`T`>은 반대로 P를 제외한 나머지를 옵셔널 + undefined로 만들기 위한 함수입니다.

- Exlcude<`keyof T,P`> : 객체가 가진 키값에서 P타입과 일치하는 키값과 제외시키는거
  - Card & Account에서 P가 Card라 한다면 account가 나옴.
  - {account: undefined}가 만들어짐.
- Partial<`B`>: B타입을 옵셔널로 만듬.
  - {account?: undefined} 로 만듬.


```ts
type PickOne<T> = One<T> & ExcludeOne<T>;
```

교차연산자로 조합을 하고,

하나는 선택한 속성값 , 하나는 undefined로 강제

이렇게 해서 단점을 보완한 Pickup<`T`>라는 커스텀 유틸리티가 완성이 됨.


```ts
withdraw({card : 'hyundai', account: 'hana'}) // Error
```

그래서 필자는 유틸리티만으로 타입추출이 어려울때는 커스텀 유틸리티라는것을 구현하라고 합니다.

핵심은 원하는 타입이 어떤 타입인지 파악하고, 필요한 타입을 작은 단위로 쪼개어 단계적으로 구현하는게 베스트.

=> 사실 잘 모르겠네요 ㅎㅎ 

### NonNullable 타입 검사 함수를 사용하여 간편하게 타입가드하기

null을 가질수 있는 값의 null처리는 자주 사용되는 타입가드 패턴의 하나인데,

if문을 사용하여 일반적으로 적용하지만, 

is키워드와 NonNullable타입으로 타입검사를 위한 유틸함수를 만들어서 사용할수도 있다.

### NonNullable 타입이란


```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```
타입스크립트에서 제공하는 내장 유틸리티 타입으로 

T가 null또는 undefined일때 never 또는 T를 반환하는 타입이다.

사용하면 null이나 undefined가 아닌 경우를 제외할 수 있다.

### null,undefined를 검사해주는 NonNullable함수

```ts
function NonNullable<T>(value:T):value is NonNullable<T>{
  return value !== null  && value !== undefined;
}
```

### Promise.all을 사용할 때, NonNullable 적용하기


## 불변 객체 타입으로 활용하기

theme객체, 자주 사용하는 애니메이션을 모아둔 객체, 상숫값을 담는 객체등 여러 방면으로 이용함.

### as const

```ts
const colors = {
  red:'#F45452',
  green:'#0C952A',
  blue:'#1A7CFF'
}

const getColorHex = (key:string) => colors[key];
```
- 객체의 키 타입을 string으로 설정하면 반환값이 any가 됨.


여기서 as const로 객체를 불변 객체로 선언하고,

keyof 연산자로 함수 인자를 colors객체에 존재하는 키값만 받도록 설정.

```ts
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
} as const;

const getColorHex = (key: keyof typeof colors) => colors[key];

```

- 컴파일 단계에서 실수방지
- 자동완성 기능을 통해 객체에 어떤값이 들어가있는지 쉽게 파악이 가능.
- 객체타입을 더 정확하고 안전하게 설정할수 있다.

### Atom 컴퍼넌트에서 theme style 객체 활용하기.

```ts
interface Props {
  fontsize?： string;
  backgroundcolor?： string;
  color?： string;
  onClick： (event: React.MouseEvent<HTMLButtonElement>) => void | Promise<void>;
}

const Button：FC<Props> = ({ fontsize, backgroundcolor, color, children })     => {
  return (
      <ButtonWrap
      fontSize={fontsize}
      backgroundColor={backgroundcolor}
      color={color}
      > {children} </ButtonWrap>
  )；
  }；
const ButtonWrap = styled.button<Omit<Props, "onClick">>`
  color： ${({ color }) => theme.color [color ?? "default"]};
  background-color： ${({ backgroundcolor }) => theme.bgColor[backgroundColor ?? "default"]};
  font-size： ${({ fontsize }) => theme.fontSizeffontSize ?? "default"]};
`
```

기존의 props를 직접 스타일값들을 넘겨줄시,

- props 타입을 string으로 설정하면 자동 완성 미지원
- 잘못된 키값 입력 시 에러 미발생

이러한 문제는 타입을 구체화 하여 해결할수 있다.

keyof,typeof을 이용하여 구체화

### typeof와 keyof 연산자를 활용

#### keyof

- 객체 타입의 키값을 리터럴 유니온 타입으로 추출

```ts
interface ColorType {
  red: string;
  green: string;
  blue: string;
}

type ColorKeyType = keyof ColorType; // 'red' | 'green' | 'blue'
```
red,green,blue가 유니온으로 나옴.


#### typeof

- 값을 타입으로 변환
- 주로 ReturnType,keyof등과 함께 사용이 됨.

```ts
const colors = { red: "#F45452", green: "#0C952A", blue: "#1A7CFF" };
type ColorsType = typeof colors; // { red: string; green: string; blue: string; }
```


이 두가지를 사용해서 ,theme 객체 타입을 구체화하고, string으로 타입을 설정했던 버튼을 개선시키면,

```ts
// Theme 객체 정의
const colors = { ,
  gray:'#222222',
  white: '#FFFFFF', 
  mint: '#00AAAA',
  black: '#000000' 
  };

const theme = {
  colors: { default: colors.gray, ...colors },
  backgroundColor: { default: colors.white, colors.gray, colors.mint, colors.black },
  fontSize: { default: "16px", small: "14px", large: "18px" }
};

// 타입 추출
type ColorType = keyof typeof theme.colors; 
// mint | white | black | gray | default
type BackgroundColorType = keyof typeof theme.backgroundColor; 
// gray | white | mint | black | default
type FontSizeType = keyof typeof theme.fontSize; 
// default | small | large

// 컴포넌트 Props 정의
interface Props {
  color?: ColorType;
  backgroundColor?: BackgroundColorType;
  fontSize?: FontSizeType;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
}
```
## Record 키를 원시타입으로 쓸시
객체 선언시 키가 어떤값인지 명확하지 않다면, Record의 키를 string이나 number같은 원시 타입으로 명시함.
이 장에서는 Record를 명시적으로 사용하는 방법을 설명.

Record 키를 원시타입으로 쓸시 문제 : "모든 문자열을 받아들이는 객체의 위험성"
### 무한한 키 집합의 문제점

무한한 키 집합은 객체가 가질 수 있는 키의 개수가 제한되지 않은 상태
```ts
type Category = string;
const foodByCategory:Reocord<Category,Food[]> = {
  한식:[{name: '제육'},{name:'뚝배기 불고기'}],
  일식 :[{name:'초밥'},{name:'텐동'}]
}
foodByCategory['양식'] // Food[]로 추론
// 무한한 키 집합
foodByCategory["양식"];     // ✅ 타입 체크 통과
foodByCategory["중식"];     // ✅ 타입 체크 통과  
foodByCategory["아무거나"]; // ✅ 타입 체크 통과
foodByCategory["123456"];   // ✅ 타입 체크 통과
// undefined이지만 타입 에러 없음.
```

Category 타입은 string,

Category를 Record의 키로 사용하는 foodBy-Category객체는 무한한 키 집합을 가지게 됨.



### 유닛 타입으로 변경하기
```ts
type Category = "한식" | "일식";
const foodByCategory: Record<Category, Food[]> = {
  한식: [{ name: "제육덮밥" }],
  일식: [{ name: "초밥" }],
};

foodByCategory["양식"]; // ❌ 타입 에러 발생

```
키가 유한한 집합이라면, 유닛 타입을 사용할수 있음.


#### 유닛타입 

  다른 타입으로 쪼개지지 않고, 오직 하나의 정확한 값을 가지는 타입.

### Partial을 이용하여 정확한 타입을 표현하기

```ts
type PartialRecord<K extends string, T> = Partial<Record<K, T>>;
type Category =string;

interface Food{
  name:string;
  //....
}


const foodByCategory: PartialRecord<Category, Food[]> = {
  한식: [{ name: "제육덮밥" },{name:"뚝불"}],
  일식: [{ name: "초밥" }],
};

foodByCategory["양식"]; // Food[] | undefined로 추론
foodByCategory["양식"]?.map(food => console.log(food.name)); // 안전한 접근
```

**Partial**은 주어진 타입의 각 프로퍼티에 ?를 붙여서 각 프로퍼티를 optional하게 만든 새로운 타입을 만들어줍니다.

