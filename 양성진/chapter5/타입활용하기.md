## 조건부 타입확장하기
### 1. extends와 제네릭을 활요한 조건부 타입

```ts
T extends U ? X : Y
```
T가 U에 할당 가능하면 X 타입, 아니면 Y 타입

### 조건부 타입을 사용하지 않을때 문제점.

핵심은 유니온타입을 사용하면 타입스크립트에서는 이게 어떤 반환타입인지 구분을 절대 못함.

예시가 어렵긴 하지만,
```ts
// 서버에서 받아오는 기본 타입
interface PayMethodBaseFromRes {
  financialCode: string;
  name: string;
}

// 은행 타입
interface Bank extends PayMethodBaseFromRes {
  fullName: string;
}

// 카드 타입
interface Card extends PayMethodBaseFromRes {
  appCardType?: string;
}

// 프론트엔드 UI 관련 타입
type PayMethodInterface = {
  companyName: string;
  // ...
}

// 최종 결제 수단 타입 (제네릭 활용)
type PayMethodInfo<T extends Bank | Card> = T & PayMethodInterface;
```


```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  // ... 구현
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess： (res) => {
    const usablePocketList =
        res?.filter((pocket： PocketInfo<Card> | PocketInfo<Bank>) => 
        pocket?.useType === "USE" ) ?? []；
    return usablePocketList;
    },
    })；

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  
  return result;
};
```

타입으로 card,appcard,bank를 받아서 해당 결제 수단의 결제 수단 정보 리스트를 반환함.

반환하는 Data 타입은 
```ts
 PocketInfo<Card> || PocketInfo<Bank>
``` 

- 사용자가 타입으로 card를 넣을시 : 
    - useGEtRegisteredList함수가 반환하는 Data타입은 PocketInfo라 유추 가능, 하지만 useGeRegisterdList가 반환하는 Data타입은 PayMethodType이기 때문에 사용하는 쪽에서는 PocketInfo일 가능성도 있음.
    -    여기서 사용자(개발자), 사용하는쪽(타입스크립트)인거 같습니다.

- useGetRegisteredList함수는 타입을 구분해서 넣는 사용자의 의도와는 다르게 정확하게 타입 반환이 안됨. 

==> 타입설정이 유니온으로만 되있기에 타입스크립트는 해당타입에 맞는 Data타입을 추론하기 어렵다. 그래서 조건부 타입을 활용해야함.


### extends 조건부 타입을 활용하여 개선하기

```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;

export const useGetRegisteredList = <T extends "card" | "appCard" | "bank">(
  type: T
): UseQueryResult<PayMethodType[]> => {
  // ... 구현
  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess： (res) => {
    const usablePocketList =
        res?.filter((pocket： PocketInfo<Card> | PocketInfo<Bank>) => 
        pocket?.useType === "USE" ) ?? []；
    return usablePocketList;
    },
    })；

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);
  
  return result;
};
```

- 제네릭과 extends를 함께 사용해 제네릭으로 받는 타입을 제한했다. 따라서 개발자는 잘못된 값을 넘길 수
없기 때문에 휴먼 에러를 방지할 수 있다.
- extends를 활용해 조건부 타입을 설정했다. 조건부 타입을 사용해서 반환 값을 사용자가 원하는 값으로 구
체화할 수 있었다. 이에 따라 불필요한 타입 가드, 타입 단언 등을 방지할 수 있다.


#### 실무 적용 포인트 (AI를 통해서 물어봤을떄)

- 언제 조건부 타입을 사용할까?
    -   ✅ 함수 입력에 따라 출력 타입이 달라질 때
    -   ✅ API 응답 타입이 요청 파라미터에 따라 달라질 때
    -   ✅ 유니온 타입 사용 시 타입 가드가 너무 많아질 때


책의 예시를 보면 type bank가 들어가냐 card,appcard가 들어가냐에 따라 달라짐.


### infer를 활용해서 타입 추론하기

extends를 사용할때, infer 키워드를 사용할수 있다.

infer의 사전적의미는 추론하다라는 의미를 지님.

타입스크립트서도 추론하는 역할을 함.

삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고, infer로 타입을 추론하는 방식을 취함.

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

>```ts
> - T가 Promise<infer K>[] 형태인지 확인
> - 맞다면 Promise 안의 타입을 K로 추론해서 반환
> - 아니면 any 반환
> ```


실무의 예시로 라이더 어드민 서비스서 이용하는 타입을 예시로 들어줌


```ts
interface RouteBase {
  name: string;  // ❌ 그냥 string
  path: string;
  component: ComponentType;
}

export interface RouteItem {
  name: string;  // ❌ 그냥 string
  path: string;
  component?: ComponentType;
  pages?: RouteBase[];
}

// 라우트 정의
export const routes: RouteItem[] = [
  {
    name: "기기 내역 관리",
    path: "/device-history",
    component: DeviceHistoryPage,
  },
  {
    name: "헬멧 인증 관리",
    path: "/helmet-certification",
    component: HelmetCertificationPage,
  },
];

// 메뉴 타입 정의
export interface SubMenu {
  name: string;  // ❌ 그냥 string
  path: string;
}

export interface MainMenu {
  name: string;  // ❌ 그냥 string
  path?: string;
  subMenus?: SubMenu[];
}

export type MenuItem = MainMenu | SubMenu;

// 메뉴 정의
export const menuList: MenuItem[] = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
];
```
내용이 뭔가 제 머리로는 이해는 안되는데요

핵심적인거만 이해하면,

menuList는 유니온으로 (MainMenu | SubMenu)로 이뤄져있고,
routes는 구조가 또 다르기에 name값의 위치가 구조마다 다름.

mainList안에 서브가 없다면 mainList.name이 권한비교 대상이고,
있다면 subList.name이 권한비교 대상이다.
routes에서는 RouteItem.name이다.

결국 name을 기준으로 권한을 판단하게 된다.

name을 그냥 스트링으로 쓰게 되면,어디서든 name을 스트링으로 아무렇게나 써도 컴파일 단계에서 에러가 나지 않는다는것이다. 

권한체크를 올바르게작동하려면, name값의 정확한 문자열로 통일이 되어야한다.


처음엔, menuList에서 name값을 타입으로 만들어서 추출하는데

```ts
type PermissionNames = "기기 정보 관리" | "안전모 인증 관리" | "운행 여부 조회"; // ...
```
권한 검사가 필요없는 name들도 있는데 얘네는 또 따로 관리해야하니까 유지보수 측면에서 어렵습니다.

그래서 이것을 해결하기위해, 필자는 infer + as const로 불변객체를 만드는것을 해결 방법으로 얘기하고 있습니다.

as const로 리터럴 타입 + 읽기전용으로 배열을 만듬.

```ts
export const menuList = [
  {
    name: "계정 관리",
    subMenus: [
      { name: "기기 내역 관리", path: "/device-history" },
      { name: "헬멧 인증 관리", path: "/helmet-certification" },
    ],
  },
  {
    name: "운행 관리",
    path: "/operation",
  },
] as const;  // ✅ 불변 객체로 만듦
```
as const를 사용해서, name값이 리터럴 타입으로 고정됨. 결국 타입을 좁혀서 정확하게 체크하기 위해서 만들어 놓고,


```ts
type UnpackMenuNames<T extends ReadonlyArray<MenuItem>> = 
  
  // ═══════════════════════════════════════════════════════════
  // 1단계: 배열인가?
  // ═══════════════════════════════════════════════════════════
  T extends ReadonlyArray<infer U>
    ? // ─────── Yes: 배열임 (U = 배열 요소 타입)
      
      // ═══════════════════════════════════════════════════════
      // 2단계: U가 MainMenu인가?
      // ═══════════════════════════════════════════════════════
      U extends MainMenu
        ? // ─────── Yes: MainMenu임
          
          // ═════════════════════════════════════════════════
          // 3단계: subMenus 추출
          // ═════════════════════════════════════════════════
          U["subMenus"] extends infer V
            ? // ─────── subMenus를 V로 추출 성공
              
              // ═══════════════════════════════════════════
              // 4단계: V가 SubMenu 배열인가?
              // ═══════════════════════════════════════════
              V extends ReadonlyArray<SubMenu>
                ? UnpackMenuNames<V>  // ✅ Yes: 재귀 호출
                : U["name"]           // ✅ No: MainMenu의 name 반환
              
            : never  // ← 3단계 실패 (여기는 거의 안 옴)
          
        : // ─────── No: MainMenu 아님
          
          // ═════════════════════════════════════════════════
          // 2단계(else): U가 SubMenu인가?
          // ═════════════════════════════════════════════════
          U extends SubMenu
            ? U["name"]  // ✅ Yes: SubMenu의 name 반환
            : never      // ✅ No: 둘 다 아님
    
    : never  // ← 1단계 실패: 배열 아님
```
unpackMenuNames를 다시 명확하게 정의합니다.

최종 PermissionNames 타입을 만듬.
```ts
export type PermissionNames = UnpackMenuNames<typeof menuList>;
```

코드가 보기 넘 힘들고 어려워서 클로드로 들여쓰기에 단계별로 쉽게 설명좀 해달라고 했습니다..
근데도 솔직히 진짜 infer로 설명하는거 UnpackMenuNames가 진짜 이해도,보기에도 너무 어렵습니다.

infer가 결국엔 어떤 타입인지 모를떄, 복잡한 구조안에서, 그 타입이 뭔지 모르니까 자동적으로 추론해서 쓰이는거구나 정도로 이해했습니다.

한번도 써본적이 없다보니까 감이 안잡히네요. 나중에 실무에서 이런 케이스가 있다면, 써보고 싶은데 그때 되면 생각이 날까? 싶습니다.. ㅠㅠ



### 템플릿 리터럴 타입 활용하기

타입스크립트에서는 유니온타입을 사용하여 변수 타입을 특정 문자열로 지정 할수 있다.

```ts

type headingNumber = 1 | 2 | 3 | 4 | 5;

type HeaderTag = `h${headingNumber}`
```

## 커스텀 유틸리티 타입 활용하기
유틸리티 타입을 활용해서 커스텀 유틸리티 타입을 제작해서 사용할수 있다.

### 유틸리티 함수를 활용해 styled-components의 중복 타입 선언 피하기

```ts
export type Props = {
  height?: string;
  color?: keyof typeof colors;
  isFull?: boolean;
  className?: string;
};

// ✅ Pick 사용 (좋은 방법)



export const Hr:VFC<props> = ({height,color,isFull,className}) => {
    ...
    return <HrComponent height={height} color={color} isFull={isFull}/>
}


// style.ts

type StyledProps = {
  height?: string;     
  color?: keyof typeof colors;  
  isFull?: boolean;    
};


const HrComponent = styled.hr<StyledProps>`
  height: ${({ height }) => height || "10px"};
  background-color: ${({ color }) => colors[color || "gray7"]};
  ${({ isFull }) => isFull && css`margin: 0 -15px;`}
`;
```

Hr컴포넌트와 style.ts안에 HrComponent는 받는 Props속성이 같습니다.

Props와 StyledProps는 className을 제외한 나머지는 같습니다. 
결국 타입이 몇개가 중복이 되는데 저게 타입이 많아지면 중복되는게 많아지면서 관리하기 어려워집니다.

그럴떄 Pick,Omit으로 커스텀해서 개선할수 있습니다.

```ts

type StyledProps = Pick<Props,'height' | 'color' |'isFull'>
```

이런식으로 코드 중복도 방지되고, 간결해지는걸 볼수 있습니다.

### PickOne 커스텀 유틸리티 타입을 활용해서 만들어보자. 

서로 다른 2개 이상의 객체를 유니온 타입으로 받을때, 타입 검사가 재대로 진행되지 않은 이슈.

```ts
type Card = {
  card: string;
}

type Account ={
  account : string;
}

function withdraw(type: Card | Account) {
  ...
}

withdraw({card : 'hyundai', account: 'hana'})

```

기존의 4장에서, 식별할 수 있는 유니온타입으로 만들수 있지만, 이미 만들어져있는걸 바꾸는건 쉽지 않음.


### 구현하는것.

여러 속성중 하나의 속성만 받는 커스텀 유틸리티 타입을 구현.

#### 1. 정확하게 어떤 것을 구현할지 타입을 정해야한다.


```ts

type Card = {
  card :string;
}

type Account = {
  account: string
}
```

Card 와 Account가 구현해야하는 타입으로 정하고,

#### 2. 원치 않는 속성에 값을 넣었을때, 의도적으로 에러 발생하기 

이것은 원하는 속성을 제외한 나머지는 에러를 일으키고 원하고자 하는 속성만 받도록 구현 하는것이다.

- 옵셔널 + undefined로 타입을 지정하기

```ts
// card 의 속성만 받고 싶다면

{account?:undefined; card:string;}

// accout의 속성만 받고 싶다면,
{account:undefined; card?:string;}
```

속성을 하나 더 추가해서 이해해보면

```ts
type PayMethod =
| { account： string; card?： undefined; payMoney?： undefined }
| { account： undefined; card?： string; payMoney?： undefined }
| { account： undefined; card?： undefined; payMoney?： string };
```

이를 커스텀 유틸리티 타입으로 구현하면,

```ts
type PickOne<T> = {
  [P in keyof T]: Record<P,T[P]> & Partial<Record<Exclude<keyof T,P>,undefined>>>
}[keyof T]

내용은 좀 어려웠는데, 제가 이해한 흐름은


```
#### One<`T`>

```ts
type One<T> = {[P in keyof T]:Record<P,T[P]>}[keyof T]
```

- [P in keyof T] : P는 T객체의 키값.
- Record<P,T[P]> : 키는 P타입, Value는 P를 키값으로 둔 T 객체의 값의 레코드 타입.
- 키는 T객체의 키값, value는 해당 키의 원복 객체 T를 말함.


```ts
// card로 예시를 들면

//keyof Card = 'card',

//[P in keyof T] => [P in 'card']
// P가 카드면,
//P = 'card'

// Record<P,T[P]> = Record<'card',Card['card']>
// => Record<'card',string> = {card:string;} 
// {[P in keyof Card]: Record<P,Card[P]>}

// P가 card니까

// { card:Record<"card",string> }
// 키는 card, 값은 {card:string};
// 결국은
// {card: {card:string}} 이런 형태에서
// [keyof T]

type Temp = {
  card:{card:string};
}

Temp[keyof Card] = Temp["card"] = {card :string}

```
그래서 아래의 결과는 맞게되는것.!
```ts
type Card = { card： string };
const one: One<Card> = { card： "hyundai" };
```
#### ExcludeOne<`T`>
```ts
type ExcludeOne<T> = { 
  [P in keyof T]: Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T];
```
ExcludeOne<`T`>은 반대로 P를 제외한 나머지를 옵셔널 + undefined로 만들기 위한 함수입니다.

- Exlcude<`keyof T,P`> : 객체가 가진 키값에서 P타입과 일치하는 키값과 제외시키는거
  - Card & Account에서 P가 Card라 한다면 account가 나옴.
  - {account: undefined}가 만들어짐.
- Partial<`B`>: B타입을 옵셔널로 만듬.
  - {account?: undefined} 로 만듬.


```ts
type PickOne<T> = One<T> & ExcludeOne<T>;
```

교차연산자로 조합을 하고,

하나는 선택한 속성값 , 하나는 undefined로 강제

이렇게 해서 단점을 보완한 Pickup<`T`>라는 커스텀 유틸리티가 완성이 됨.


```ts
withdraw({card : 'hyundai', account: 'hana'}) // Error
```

그래서 필자는 유틸리티만으로 타입추출이 어려울때는 커스텀 유틸리티라는것을 구현하라고 합니다.

핵심은 원하는 타입이 어떤 타입인지 파악하고, 필요한 타입을 작은 단위로 쪼개어 단계적으로 구현하는게 베스트.

=> 사실 잘 모르겠네요 ㅎㅎ 

### NonNullable 타입 검사 함수를 사용하여 간편하게 타입가드하기

null을 가질수 있는 값의 null처리는 자주 사용되는 타입가드 패턴의 하나인데,
if문을 사용하여 일반적으로 적용하지만, is키워드와 NonNullable타입으로 타입검사를 위한 유틸함수를 만들어서 사용할수도 있다.

### NonNullable 타입이란


```ts
type NonNullable<T> = T extends null | undefined ? never : T;
```
타입스크립트에서 제공하는 내장 유틸리티 타입으로 

T가 null또는 undefined일때 never 또는 T를 반환하는 타입이다.

사용하면 null이나 undefined가 아닌 경우를 제외할 수 있다.

### null,undefined를 검사해주는 NonNullable함수

```ts
function NonNullable<T>(value:T):value is NonNullable<T>{
  return value !== null  && value !== undefined;
}
```

### Promise.all을 사용할 때, NonNullable 적용하기


## 불변 객체 타입으로 활용하기

theme객체, 자주사용하는 애니메이션을 모아둔 객체, 상숫값을 담는 객체등 여러 방면으로 이용함.

### as const

```ts
const colors = {
  red:'#F45452',
  green:'#0C952A',
  blue:'#1A7CFF'
}

const getColorHex = (key:string) => colors[key];
```
- 객체의 키 타입을 string으로 설정하면 반환값이 any가 됨.


여기서 as const로 객체를 불변 객체로 선언하고,

keyof 연산자로 함수 인자를 colors객체에 존재하는 키값만 받도록 설정.

```ts
const colors = {
  red: "#F45452",
  green: "#0C952A",
  blue: "#1A7CFF",
} as const;

const getColorHex = (key: keyof typeof colors) => colors[key];

```

- 컴파일 단계에서 실수방지
- 자동완성 기능을 통해 객체에 어떤값이 들어가있는지 쉽게 파악이 가능.
- 객체타입을 더 정확하고 안전하게 설정할수 있다.

### Atom 컴퍼넌트에서 theme style 객체 활용하기.

```ts
interface Props {
  fontsize?： string;
  backgroundcolor?： string;
  color?： string;
  onClick： (event: React.MouseEvent<HTMLButtonElement>) => void | Promise<void>;
}

const Button：FC<Props> = ({ fontsize, backgroundcolor, color, children })     => {
  return (
      <ButtonWrap
      fontSize={fontsize}
      backgroundColor={backgroundcolor}
      color={color}
      > {children} </ButtonWrap>
  )；
  }；
const ButtonWrap = styled.button<Omit<Props, "onClick">>`
  color： ${({ color }) => theme.color [color ?? "default"]};
  background-color： ${({ backgroundcolor }) => theme.bgColor[backgroundColor ?? "default"]};
  font-size： ${({ fontsize }) => theme.fontSizeffontSize ?? "default"]};
`
```

기존의 props를 직접 스타일값들을 넘겨줄시,

- props 타입을 string으로 설정하면 자동 완성 미지원
- 잘못된 키값 입력 시 에러 미발생

이러한 문제는 타입을 구체화 하여 해결할수 있다.

keyof,typeof을 이용하여 구체화

### typeof와 keyof 연산자를 활용

#### keyof

- 객체 타입의 키값을 리터럴 유니온 타입으로 추출

```ts
interface ColorType {
  red: string;
  green: string;
  blue: string;
}

type ColorKeyType = keyof ColorType; // 'red' | 'green' | 'blue'
```
red,green,blue가 유니온으로 나옴.


#### typeof

- 값을 타입으로 변환
- 주로 ReturnType,keyof등과 함께 사용이 됨.

```ts
const colors = { red: "#F45452", green: "#0C952A", blue: "#1A7CFF" };
type ColorsType = typeof colors; // { red: string; green: string; blue: string; }
```


이 두가지를 사용해서 ,theme 객체 타입을 구체화하고, string으로 타입을 설정했던 버튼을 개선시키면,

```ts
// Theme 객체 정의
const colors = { 
  red: "#F45452", 
  green: "#0C952A", 
  blue: "#1A7CFF",
  gray:'#222222',
  white: '#FFFFFF', 
  mint: '#00AAAA',
  black: '#000000' 
  };

const theme = {
  colors: { default: colors.gray, ...colors },
  backgroundColor: { default: colors.white, colors.gray, colors.mint, colors.black },
  fontSize: { default: "16px", small: "14px", large: "18px" }
};

// 타입 추출
type ColorType = keyof typeof theme.colors; 
// mint | white | black | red | green | blue | gray| default
type BackgroundColorType = keyof typeof theme.backgroundColor; 
// gray | white | mint | black | default
type FontSizeType = keyof typeof theme.fontSize; 
// default | small | large

// 컴포넌트 Props 정의
interface Props {
  color?: ColorType;
  backgroundColor?: BackgroundColorType;
  fontSize?: FontSizeType;
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
}
```